> 采用一问一答的形式，还原面试官提问场景。

- 数据库基础
  - 什么是事务？
  - 事务的四种特性？
  - 并发情况下会出现什么问题？
  - 不可重复读和幻读的区别？
  - 数据库的四种隔离级别？
  - 数据库两种常用的存储引擎？
  - 数据库水平切分和垂直切分是什么？
  - 数据库锁的种类，加锁的方式？
  - 数据库的三种范式？
  - 数据库的优化方法？
  - 说一说数据连接池的工作机制是什么？
  - jion 与 union 区别？
  - 触发器？
  - SQL 去重？
  - 分库分表如何实现？具体分几个库几个表，主从复制，读写分离？
  - 有哪些常用的 sql 优化方式？
  - 数据库自增主键可能造成的问题？
  - MVCC 的含义，如何实现的？
  - 数据库从单机扩展到分布式会遇到什么问题，怎么解决？
  - SQL 解析顺序？
  - 关系型和非关系型数据库的区别（各自优点）？
  - 数据库的索引类型以及优缺点，什么时候使用索引，什么时候不能使用索引？
  - 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）？
  - 视图的作用与使用方法（如何删除等）？
- MySQL
  - 简单介绍下 MySQL 的架构？
  - 说说 MySQL 的索引，索引的类型有哪些，如何创建合理的索引，索引如何优化，索引什么时候会失效？？
  - 索引创建的规则？
  - 为什么 MySQL 索引要用 B+ 树，为何不采用红黑树或 B 树？
  - 索引最左匹配？
  - 索引失效情况？
  - MySQL 有哪些存储引擎，各自优缺点？
  - 介绍一下什么时候用 InnoDB 什么时候用 MyISAM？
  - MyISAM 和 InnoDB 引擎索引结构有什么区别？
  - MySQL 的主从复制？
  - leftjoin 和 rightjoin 的区别？
  - 为什么数据库使用索引查询速度会那么快，是怎样实现的？
  - 除了 MySQL 这种关系型数据库外，还有哪些数据库？
  - MySQL 是怎么在 RR 情况下解决幻读的？
  - MySQL 慢查询优化？
  - MySQL 主从切换过程了解吗？在切换的时候如果有请求过来会怎么做？
  - MySQL 数据存储格式？
  - MySQL 的索引有哪几种，原理以及叶子节点存储数据有什么不同？
  - ⾼并发下，如何做到安全的修改同一行数据？
  - InnoDB 的标准行级锁有哪两种，解释其含义？
  - 数据库会死锁吗？举一个死锁的例⼦，MySQL 怎么解决死锁？
  - 聚集索引和非聚集索引的区别（叶节点存储内容）？
  - 索引为什么要⽤ B+ 树实现，它是怎么分裂的，什么时候分裂，为什么是平衡的？
  - 某个表有近千万数据， CRUD 比较慢，如何优化？
  - MySQL 怎么优化 table scan 的？
  - 如何写 sql 能够有效的使用到复合索引？
  - MySQL 中 in 和 exists 的区别？
  - MySQL 的主从延迟怎么解决？
  - 谈谈 explain 结果中⽐较关键的指标，以及指标的含义？
  - 了解 MySQL 的 redo 和 undo 日志吗？
  - MySQL 的表空间方式，各自特点？
  - 分布式事务了解过吗？
- Redis
  - 什么是 Redis？有什么特点？
  - Redis 支持的数据结构类型？各自都适合什么样的场景？
  - Redis 为什么快？
  - 说一说 Redis 持久化机制，RDB 和 AOF 的区别？
  - Redis 高可用？
  - 说一说 Redis 的锁？
  - 读写分离模型及适用场景？
  - 数据分片模型及适用场景？
  - Redis 的回收策略？
  - 使用 Redis 有哪些好处？
  - Redis 与 Memcached 的区别有哪些？
  - Redis 常见性能问题和解决方案？
  - Redis 的适用场景？
  - 常见的缓存策略有哪些，如何做到缓存(⽐如 Redis)与 DB 里的数据一致性？
  - 如何防止缓存击穿和雪崩？
  - 缓存数据过期后的更新如何设计？
  - Redis 的使⽤要注意什么，内存设置，淘汰策略等？
  - Redis 的并发竞争问题如何解决？
  - 了解 Redis 事务的 CAS 操作吗？
  - Redis 的选举算法和流程是怎样的？
  - Redis 的集群怎么同步的数据的？
  - 知道哪些 Redis 的优化操作？
  - Reids 的主从复制机制原理？
  - Redis 的线程模型是什么？
  - 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点？
  - 本地缓存在并发使用时的注意事项？
- 其它
  - JDBC 中如何进行事务处理？
  - JDBC 的反射是什么？
  - JDO 是什么？
  - Statement 和 PreparedStatement 有什么区别？哪个性能更好？
  - 使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？
  - 负载均衡怎么实现？


# 什么是事务？
**事务**（transaction）是一组原子性的 SQL 查询，或者说是一个独立的工作单元。即在满足 ACID 特性的前提下，如果其中有任何一条语句因为崩溃或其它原因无法成功，那么所有的语句都不会执行。事务内的语句，要么全部执行成功，要么全部执行失败。

# 事务的四种特性？
- **原子性**（atomicity）：根据事务的定义，事务被视为一个不可分割的最小工作单元。事务中包含多条语句，整个事务中的所有操作要么全部提交（commit）成功，要么全部失败回滚(rollback)。
- **一致性**（consistency）：数据库总是从一个一致性的状态转换到另一个一致性的状态。即在事务执行前后都保持一致性状态。例如在事务提交之前，系统出现了错误或崩溃，由于事务还没有提交，所以事务中所做的修改也不会保存到数据库中。
- **隔离性**（isolation）：通常情况下，一个事务所做的修改在最终提交之前，对其它事务都是不可见的。但事务的隔离性很难保证，往往在并发情况下会出现并发一致性问题。
- **持久性**（durability）：一旦事务进行了提交，则其所做的修改就会永远保存到数据库中，即对数据的修改是永久性的。

# 并发情况下会出现什么问题？
多事务并发运行通常会操作（例如“读”）相同的数据来完成各自的工作，因此会带来如下的多事务并发问题：
- **丢失修改**（Lost to modify）：事务 A 在提交事务之前对数据进行了修改，此时事务 B 也对同一数据进行了修改，由于事务 B 覆盖了之前事务 A 的修改，所以事务 A 的修改就被丢失了。
- **脏读**（Dirty Read）：事务 A 读取到了事务 B 已修改但未提交到数据库中的数据，由于事务 B 还未提交，所以事务 A 读取到的数据被称为脏数据，此行为称为脏读。
- **不可重复读**（Nonrepeatable Read）：指在某一事务内多次读同一数据有可能每次读到的数据是不同的。例如，在事务未提交之前，事务 A 读取了某一数据，此时事务 B 对该数据进行了**修改**，那么事务 A 再次读取该数据的话得到的数据和第一次读的可能是不同的，因此就发生了在同一事务内两次读到的数据是不一样的情况，此时就发生了不可重复读。
- **幻读**（Phantom Read）：事务 A 读取某个**范围**内的数据，此时事务 B 在该范围内**插入**了新的数据，等到事务 A 再次读取该范围内数据的时候发现多了原本不存在的记录，即此时读取的结果集和第一次读取的结果集不同，就好像发生了幻觉一样，所以称为幻读。

# 不可重复读和幻读的区别？
不可重复读和幻读类似，都是针对某一事务前后读取的结果不同从而产生的不同现象。但不可重复读的重点在于对同一数据的修改，而幻读的重点是新增或者删除数据，在于范围。

# 数据库的四种隔离级别？
- Read Uncommitted（读未提交）：最低的隔离级别，对于事务中的修改，即使没有提交，则对其它事务也都是可见的，即允许读取尚未提交的数据变更，可能会产生脏读、幻读或不可重复读。
- Read Committed（读已提交）：允许提交并发事务已经提交的数据，即一个事务只能看见已经提交的事务所做的修改。也就是说，一个事务从开始到提交之前，所做的任何修改对其它事务都是不可见的。可避免脏读。
- Repeatable Read（可重复读）：该级别可以保证在同一个事务中多次读取同样记录的结果是一致的。MySQL 的默认级别，可避免不可重复读。
- Serializable（可串行化）：最高的隔离级别，强制事务串行执行，在读取的每一行数据上多加锁，但有可能导致大量的超时和锁争用的问题。避免了幻读。

# 数据库两种常用的存储引擎？
