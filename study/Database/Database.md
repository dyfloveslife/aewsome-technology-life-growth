> 采用一问一答的形式，还原面试官提问场景。

- 数据库基础
  - 什么是事务？
  - 事务的四种特性？
  - 并发情况下会出现什么问题？
  - 不可重复读和幻读的区别？
  - 数据库的四种隔离级别？
  - 数据库两种常用的存储引擎？
  - 数据库水平切分和垂直切分是什么？
  - 什么是悲观锁和乐观锁？
  - 数据库锁的粒度、种类、加锁的方式？
  - 数据库的三种范式？
  - 数据库的优化方法？
  - 说一说数据连接池的工作机制是什么？
  - jion 与 union 区别？
  - 触发器？
  - SQL 去重？
  - 分库分表如何实现？具体分几个库几个表，主从复制，读写分离？
  - 有哪些常用的 sql 优化方式？
  - 数据库自增主键可能造成的问题？
  - MVCC 的含义，如何实现的？
  - 数据库从单机扩展到分布式会遇到什么问题，怎么解决？
  - SQL 解析顺序？
  - 关系型和非关系型数据库的区别（各自优点）？
  - 数据库的索引类型以及优缺点，什么时候使用索引，什么时候不能使用索引？
  - 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）？
  - 视图的作用与使用方法（如何删除等）？
- MySQL
  - 简单介绍下 MySQL 的架构？
  - 说说 MySQL 的索引，索引的类型有哪些，如何创建合理的索引，索引如何优化，索引什么时候会失效？？
  - 索引创建的规则？
  - 为什么 MySQL 索引要用 B+ 树，为何不采用红黑树或 B 树？
  - 索引最左匹配？
  - 索引失效情况？
  - MySQL 有哪些存储引擎，各自优缺点？
  - 介绍一下什么时候用 InnoDB 什么时候用 MyISAM？
  - MyISAM 和 InnoDB 引擎索引结构有什么区别？
  - MySQL 的主从复制？
  - leftjoin 和 rightjoin 的区别？
  - 为什么数据库使用索引查询速度会那么快，是怎样实现的？
  - 除了 MySQL 这种关系型数据库外，还有哪些数据库？
  - MySQL 是怎么在 RR 情况下解决幻读的？
  - MySQL 慢查询优化？
  - MySQL 主从切换过程了解吗？在切换的时候如果有请求过来会怎么做？
  - MySQL 数据存储格式？
  - MySQL 的索引有哪几种，原理以及叶子节点存储数据有什么不同？
  - ⾼并发下，如何做到安全的修改同一行数据？
  - InnoDB 的标准行级锁有哪两种，解释其含义？
  - 数据库会死锁吗？举一个死锁的例⼦，MySQL 怎么解决死锁？
  - 聚集索引和非聚集索引的区别（叶节点存储内容）？
  - 索引为什么要⽤ B+ 树实现，它是怎么分裂的，什么时候分裂，为什么是平衡的？
  - 某个表有近千万数据， CRUD 比较慢，如何优化？
  - MySQL 怎么优化 table scan 的？
  - 如何写 sql 能够有效的使用到复合索引？
  - MySQL 中 in 和 exists 的区别？
  - MySQL 的主从延迟怎么解决？
  - 谈谈 explain 结果中⽐较关键的指标，以及指标的含义？
  - 了解 MySQL 的 redo 和 undo 日志吗？
  - MySQL 的表空间方式，各自特点？
  - 分布式事务了解过吗？
- Redis
  - 什么是 Redis？有什么特点？
  - Redis 支持的数据结构类型？各自都适合什么样的场景？
  - Redis 为什么快？
  - 说一说 Redis 持久化机制，RDB 和 AOF 的区别？
  - Redis 高可用？
  - 说一说 Redis 的锁？
  - 读写分离模型及适用场景？
  - 数据分片模型及适用场景？
  - Redis 的回收策略？
  - 使用 Redis 有哪些好处？
  - Redis 与 Memcached 的区别有哪些？
  - Redis 常见性能问题和解决方案？
  - Redis 的适用场景？
  - 常见的缓存策略有哪些，如何做到缓存(⽐如 Redis)与 DB 里的数据一致性？
  - 如何防止缓存击穿和雪崩？
  - 缓存数据过期后的更新如何设计？
  - Redis 的使⽤要注意什么，内存设置，淘汰策略等？
  - Redis 的并发竞争问题如何解决？
  - 了解 Redis 事务的 CAS 操作吗？
  - Redis 的选举算法和流程是怎样的？
  - Redis 的集群怎么同步的数据的？
  - 知道哪些 Redis 的优化操作？
  - Reids 的主从复制机制原理？
  - Redis 的线程模型是什么？
  - 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点？
  - 本地缓存在并发使用时的注意事项？
- 其它
  - JDBC 中如何进行事务处理？
  - JDBC 的反射是什么？
  - JDO 是什么？
  - Statement 和 PreparedStatement 有什么区别？哪个性能更好？
  - 使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？
  - 负载均衡怎么实现？
- 参考

# 数据库基础
## 什么是事务？
**事务**（transaction）是一组原子性的 SQL 查询，或者说是一个独立的工作单元。即在满足 ACID 特性的前提下，如果其中有任何一条语句因为崩溃或其它原因无法成功，那么所有的语句都不会执行。事务内的语句，要么全部执行成功，要么全部执行失败。

## 事务的四种特性？
- **原子性**（atomicity）:根据事务的定义，事务被视为一个不可分割的最小工作单元。事务中包含多条语句，整个事务中的所有操作要么全部提交（commit）成功，要么全部失败回滚(rollback)。
- **一致性**（consistency）:数据库总是从一个一致性的状态转换到另一个一致性的状态。即在事务执行前后都保持一致性状态。例如在事务提交之前，系统出现了错误或崩溃，由于事务还没有提交，所以事务中所做的修改也不会保存到数据库中。
- **隔离性**（isolation）:通常情况下，一个事务所做的修改在最终提交之前，对其它事务都是不可见的。但事务的隔离性很难保证，往往在并发情况下会出现并发一致性问题。
- **持久性**（durability）:一旦事务进行了提交，则其所做的修改就会永远保存到数据库中，即对数据的修改是永久性的。

## 并发情况下会出现什么问题？
多事务并发运行通常会操作（例如“读”）相同的数据来完成各自的工作，因此会带来如下的多事务并发问题:
- **丢失修改**（Lost to modify）:事务 A 在提交事务之前对数据进行了修改，此时事务 B 也对同一数据进行了修改，由于事务 B 覆盖了之前事务 A 的修改，所以事务 A 的修改就被丢失了。
- **脏读**（Dirty Read）:事务 A 读取到了事务 B 已修改但未提交到数据库中的数据，由于事务 B 还未提交，所以事务 A 读取到的数据被称为脏数据，此行为称为脏读。
- **不可重复读**（Nonrepeatable Read）:指在某一事务内多次读同一数据有可能每次读到的数据是不同的。例如，在事务未提交之前，事务 A 读取了某一数据，此时事务 B 对该数据进行了**修改**，那么事务 A 再次读取该数据的话得到的数据和第一次读的可能是不同的，因此就发生了在同一事务内两次读到的数据是不一样的情况，此时就发生了不可重复读。
- **幻读**（Phantom Read）:事务 A 读取某个**范围**内的数据，此时事务 B 在该范围内**插入**了新的数据，等到事务 A 再次读取该范围内数据的时候发现多了原本不存在的记录，即此时读取的结果集和第一次读取的结果集不同，就好像发生了幻觉一样，所以称为幻读。

## 不可重复读和幻读的区别？
不可重复读和幻读类似，都是针对某一事务前后读取的结果不同从而产生的不同现象。但不可重复读的重点在于对同一数据的修改，而幻读的重点是新增或者删除数据，在于范围。

## 数据库的四种隔离级别？
- **Read Uncommitted**（读未提交）:最低的隔离级别，对于事务中的修改，即使没有提交，则对其它事务也都是可见的，即允许读取尚未提交的数据变更，可能会产生脏读、幻读或不可重复读。
- **Read Committed**（读已提交）:允许提交并发事务已经提交的数据，即一个事务只能看见已经提交的事务所做的修改。也就是说，一个事务从开始到提交之前，所做的任何修改对其它事务都是不可见的。可避免脏读。
- **Repeatable Read**（可重复读）:该级别可以保证在同一个事务中多次读取同样记录的结果是一致的。MySQL 的默认级别，可避免不可重复读。
- **Serializable**（可串行化）:最高的隔离级别，强制事务串行执行，在读取的每一行数据上多加锁，但有可能导致大量的超时和锁争用的问题。避免了幻读。

## 数据库两种常用的存储引擎？
常见的有 InnoDB 和 MyISAM:
- **InnoDB** 是 MySQL 默认的**事务型**引擎，默认的隔离级别是 Repeatable read（可重复读），通过间隙锁（next-key locking）策略防止幻读的出现。其内部做了许多优化，如从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。
- **MyISAM** 不支持事务和行级锁，崩溃后无法安全恢复。其对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。

**如何选择合适的存储引擎？**

除非需要用到某些 InnoDB 不具备的特性，否则都应该优先选择 InnoDB 引擎。如果不在乎可扩展能力和并发能力，也不在乎崩溃后的数据丢失问题，而对 InnoDB 的空间占用过多比较敏感的话，则建议选择 MyISAM。

- 如果想要支持**事务**，则 InnoDB 是目前最稳定的；
- 如果考虑到**备份**，则 InnoDB 满足在线热备份的需求；
- 如果考虑到**奔溃恢复**的能力，MyISAM 崩溃后发生损坏的概率比 InnoDB 要高很多，而且恢复速度也要慢；
- 如果考虑到存储引擎**特有的一些特性**，例如只有 MyISAM 支持地理空间索引。

## 数据库水平切分和垂直切分是什么？
通过某种特定的条件，按照某个维度，将存放在同一数据库中的数据分散到多个数据库中，以实现分散主库负载的目的。
- 垂直切分:将含有多个列的表拆分成多个表，解决表的宽度问题，可分为:
  - 将不常用的字段单独放在一个表中；
  - 将大字段独立放在一个表中；
  - 将经常使用的字段放在一起；
  - 优点:
    - 由于每个表对应的是不同的业务，垂直切分是按照业务将表进行分类，分不到不同的数据库上。
    - 所以拆分后业务更加清晰、拆分规则明确、系统之间整合或扩展容易、数据维护简单。
  - 缺点:
    - 部分业务表无法 join，只能通过接口的方式解决，系统的复杂度上升了；
    - 存在单库性能瓶颈；
    - 事务处理复杂。
- 水平切分:垂直拆分是将不同表拆分到不同的数据库中，而水平拆分是把同一个表拆分到不同的数据库中。水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构是完全一致的。常用的方式有:
  - 对 ID 进行 hash 计算，例如要拆分成 5 个表，则 ID % 5 可以拆分到 0、1、2、3、4 上；
  - 针对不同的 hashID 将数据存入不同的表中。
  - 优点:
    - 表拆分后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；
    - 不存在单库大数据、高并发的性能瓶颈；
    - 按照合理的拆分规则进行拆分的话，join 操作基本避免跨库。
  - 缺点:
      - 拆分规则难以抽象；
      - 分片事务一致性难以解决。

## 什么是悲观锁和乐观锁？
悲观锁和乐观锁是两种常见的资源并发锁设计思路，适用于并发编程。

**悲观锁:**先获得锁，然后再进行业务操作，即“悲观”的认为所有的操作都会造成并发安全问题，因此要先确保获取锁成功以后再进行相应的业务。适用于**数据更新比较频繁**，即**写多读少**的场景。

**乐观锁:**先进行业务操作，只有在最后更新数据时进行检查数据是否被其它事务修改过，若没有被修改过，则更新成功，否则失败重试。该锁认为当前的操作不会产生并发问题，即当前不会有其它线程对数据进行修改，因此不会上锁。适用于**读多写少**的场景，由于乐观锁在发生失败回滚的时候开销比较大，因此适用于在取锁失败概率较小的场景，从而提高系统的并发性能。实现方式如下:
  - 在需要锁的数据上增加一个版本号或者时间戳，每次数据更新的同时也更新该字段；
  - 先读取想要更新的字段，在实际更新的时候检查一下，若该字段没有变化，则不更新；若变化了，则更新。

## 数据库锁的粒度、种类、加锁的方式？
**封锁的粒度:** 

MySQL 提供了两种封锁的粒度:**行级锁（row lock）**和**表级锁（table lock）**。

**行级锁（row lock）:**
  - 只有在存储引擎实现，而 MySQL 服务器层没有实现。

**表级锁（table lock）:**
  - 表锁是 MySQL 中最基本的锁策略，开销最小。
  - 一个用户对表进行写操作（插入、删除、更新等）前，会先获得写锁。这会阻塞其他用户对该表的所有读写操作。
  - 当没有写锁时，其他读取的用户才能获得读锁，读锁之间不相互阻塞。

**锁粒度的选择:**
  - 让锁定的对象更具有选择性，尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的情况是，只会对修改的数据片进行精确的锁定。
  - 在锁的开销和数据安全之间寻求平衡，锁定的数据量越小，则发生锁争用的可能性就越小，系统的并发程度就越高。
  - 但加锁也会消耗资源，所的各种操作（获取、释放、检查锁的状态）都会增加系统开销。
  - 封锁粒度越小，越精细，则系统开销就越大。

**锁的类型:**
  - **共享锁（shared lock）/ S 锁:**也叫读锁，如果事务 T1 对数据 A 加了 S 锁，则可以对 A 进行读取操作，但是不能进行更新操作。加锁期间事务 T2 可以读取数据 A，但不能修改数据 A。也就是对于其它事务来说，只能加 S 锁，不能加 X 锁。
  - **排他锁（exclusive lock）/ X 锁:**也叫写锁，如果事务 T1 对数据 A 加了 X 锁，则只允许该事务对 A 进行读取和更新操作。加锁期间事务 T2 不能读取数据 A，也不能修改数据 A。也就是对于其它事务来说，既不能加 S 锁，也不能加 X 锁。
  - **意向锁（Intention locks）:**引入意向锁是因为假如事务 T 想要对某张表加 X 锁时，就需要先检测一下是否存在其它事务对该表或中该表中的某一行加了锁，在检测的时候都需要对每一行进行检测，非常耗时。
    - **意向共享锁（IS）:**指一个事务在获取 S 锁之前，一定会先在当前的表上加 IS 锁。
    - **意向排他锁（IX）:**指一个事务在获取 X 锁之前，一定会先在当前的表上加 IX 锁。

有了意向锁之后，事务 T 想要对某张表加 X 锁时，只需要检测是否有其它事务对该表加了 X/IX/S/IS 锁，如果加了就表示有其它的事务在使用该表或表中的某行的锁，因此事务 T 加 X 锁失败。

## 数据库的三种范式？
范式（Normal Form）分为多种，通常用到的三种范式有:第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。

- **第一范式:**列不可分，即列具有原子性。对于【联系人】表来说，如果存在**姓名、性别、电话**这三列的话，则不属于第一范式。因为还可以将**电话**拆分为**家用电话**和**公司电话**。
- **第二范式:**在 1NF 的基础上，表中还具有主键，并且**没有包含在主键中的列**要完全依赖于主键，而不能只依赖于主键中的一部分。
  - 比如一个【订单信息表】，其中存在的列有**订单编号、商品编号、商品名称、商品数量、单位、商品价格、客户、所属单位、联系方式**。这里的**订单编号、商品编号**是联合主键，但这里的**商品名称、单位、商品价格**等信息不与该表的主键完全相关，而是只与**商品编号**相关，即值依赖于主键中的一部分。所以这里违反了第二范式的设计原则。
  - 此时，要想符合第二范式，只需要将【订单信息表】进行拆分，将商品所属的信息拆分到另一个表中，同时把订单项目也分离到另一个表中即可。
- **第三范式:**在 2NF 的基础上，还需要非主键列必须直接依赖于主键，而不能存在传递依赖。即不能存在非主键列 A 依赖于非主键列 B，非主键 B 依赖于主键的情况。
  - 例如一个【订单信息表】，存在的列有**订单编号、订单项目、负责人、业务员、订单数量、客户编号、客户姓名**。
  - 由于**客户姓名**与**客户编号**相关，而**客户编号**又与**订单编号**相关，则最终**客户姓名**就与**订单编号**相关了。这就出现了传递依赖，不符合第三范式。

## 数据库的优化方法？
对于如何优化 MySQL 数据库，可以从 SQL 语句及索引优化、数据表结构的优化、系统配置的优化和硬件优化四个方面进行说明。
**SQL 语句及索引优化**
- 发现有问题的 SQL 语句
  - 通过 MySQL 的慢查询日志，假如语句运行时间（long_query_time）超过默认值 10 秒以上，则可以通过使用慢查询日志分析工具（pt-query-digest）分析 Row examine 属性，从而找出 IO 操作较大的 SQL，针对这样的 SQL 进行下一步优化。
- 分析 SQL 语句的执行计划
  - 使用 EXPLAIN 关键字可以知道 MySQL 是如何对 SQL 语句进行处理的。通过打印出的一些信息来优化 SQL 语句。
- SQL 语句的优化
  - 优化 INSERT 语句，即一次插入多个值；
  - 尽量避免在 WHERE 子句中使用 != 或 <> 或对 NULL 值进行判断等操作，否则引擎会放弃使用索引而进行全表扫描；
  - 优化嵌套查询:可以使用连接（JOIN）替代子查询；
  - 某些情况下使用 EXISTS 代替 IN。
- 索引的优化
  - 可以在经常需要进行查询、表连接、使用 ORDER BY、GROUP BY 后面的字段中建立索引，但需要注意以下几种可能会引起索引失效的情况:
    - 以 % 开头的 LIKE 语句进行模糊匹配时；
    - OR 语句前后没有同事使用索引时；
    - 数据类型出现隐式转化时（如 varchar 不加单引号的话可能自动转换为 int）；
    - 对于多列索引，必须满足**最左匹配原则**，因为 MySQL 会一直向右匹配直到遇到范围查询（<、>、BETWEEN、LIKE）就停止。比如 `a=1 AND b=2 AND c>3 AND d=4`，如果建立 (a,b,c,d) 顺序的索引，则 d 是用不到索引的；如果建立 (a,b,d,c) 的索引则都可以用到。此外 a、b、d 的顺序可以任意调整。

**数据库表结构优化**





## 说一说数据连接池的工作机制是什么？


## jion 与 union 区别？


## 触发器？


## SQL 去重？



## 分库分表如何实现？具体分几个库几个表，主从复制，读写分离？


## 有哪些常用的 sql 优化方式？


## 数据库自增主键可能造成的问题？


## MVCC 的含义，如何实现的？


## 数据库从单机扩展到分布式会遇到什么问题，怎么解决？


## SQL 解析顺序？


## 关系型和非关系型数据库的区别（各自优点）？


## 数据库的索引类型以及优缺点，什么时候使用索引，什么时候不能使用索引？



## 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）？



## 视图的作用与使用方法（如何删除等）？


# Redis



# 其它

# 参考
[高性能 MySQL](https://book.douban.com/subject/23008813/)
[面试/笔试第三弹 —— 数据库面试问题集锦](https://blog.csdn.net/justloveyou_/article/details/78308460)
[CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md)
[数据库设计的三大范式](https://www.cnblogs.com/o-andy-o/archive/2012/01/30/2331615.html)